import socket
import random
import math

shell.prefix("set -euo pipefail")

configfile: "config.yaml"

############### MAIN SETUP VARIABLES ##################
DATASETS_AND_K_VALS = [("spneumo_pangenome_RASE_db.unitigs_k128", list(range(15, 47, 2))),
                       ("sars-cov-2_pangenome_gisaid.unitigs_k128", list(range(15, 47, 2))),
                       ("ecoli_pangenome_661k_HQ.unitigs_k128", list(range(15, 47, 2))),
                       ("ecoli_pangenome_661k_all.unitigs_k128", [15, 23, 31]),
                       ("minikraken4GB_k31", [31]),
                       ("minikraken8GB_k31", [31]),
                       ("human_rnaseq_srx348811.unitigs_minfreq2_k32", [15, 23, 31]), # only up to 32
                       ("human_genome_assembly_chm13.v2.0", list(range(11, 47, 2))), #NOTE: subsampled only for k=23
                       ("human_genome_illumina.unitigs_minfreq2_k32", [15, 23, 31]), # only up to 32
                       ("human_microbiome_illumina_srs063932.unitigs_minfreq2_k32", list(range(15, 32, 2))), # only up to 32
                       ]

# for subsampling 
R_VALS = ["0.1", "1.0"]
SUBSAMPLED_KS = [15, 23, 31]
DATASETS_NOT_SUBSAMPLED = ["minikraken4GB_k31", "minikraken8GB_k31", "human_genome_illumina.unitigs_minfreq2_k32"]

HOSTNAME = socket.gethostname()
if HOSTNAME == "":
    HOSTNAME = "NA"
print(HOSTNAME)

NUM_QUERIED_KMERS = 1000000
STREAMING_SEQUENCES_LENGTH = 300
NEGATIVE_QUERIES_REF_FASTA="../../data/Triticum_aestivum.IWGSC.dna.chromosome.1A.fa"
NEGATIVE_QUERIES_MUT_RATE=0.1
WGSIM_STD_DEV = 31 # default is 50; wgsim ignores sequences shorter than 3*std_dev + dist
#WGSIM = "./wgsim"
GET_QUERIES = "../../scripts/get_queries.py"

RSPSS_DIR = "05_eulertigs/"
SBWT_DIR = "10_sbwt_index/"

DATA_DIR = "../../data/"

# PATH TO PROGRAMS
PROPHASM = "./prophasm"
CAMEL = "./kmercamel"
FMSI = "./fmsi"
GGCAT = "./ggcat"
SBWT = "./sbwt"
SBWT_LARGE_K = "./sbwt_large_k"
SSHASH = "./sshash"
SSHASH_LARGE_K = "./sshash_large_k"

# DEFAULT PARAMS OF PROGRAMS
SBWT_VARIANT = "plain-matrix"  # choosing the default variant now as it achieves the best query times in SBWT paper; for index size: "rrr-subsetwt" has nearly as small index as "mef-concat", but the latter produces a warning on kamenac
# SBWT variant (on kamenac): not with Elias-Fano "WARNING: This program was compiled for a CPU without support for the BMI2 instruction set. The performance of the Elias-Fano variants will be very bad."
SBWT_VARIANT_MEM = "rrr-split"  # one of the most memory efficient variant that has the best query time among the most memory-efficient variants (according to the SBWT paper)
SBWT_TMP_DIR = "./_SBWT-tmp/" #"sbwt-tmp/" #/tmp/ -- PV: note: do not use /tmp/ on servers as they have limited root dist
SBWT_RAM = "120" # SBWT -m param.: "RAM budget in gigabytes (not strictly enforced). Must be at least 2. (default: 2)"
CBL_PREF = "./CBL/target.k_" # NOTE: CBL is compiled for every k separately
CBL_SUFF = "/release/examples/cbl"
CBL_MAX_K = 59 # see https://github.com/imartayan/CBL ; NOTE: 39 was maximum possible for HG in 250 GB
NUM_THREADS = 1 # NOTE: using only 1 thread for SBWT, even though they can use more threads (for query or index building, resp., but not both)
# 
D_VALS = [1]
CAMEL_ALGS = ["global"] # also possible: "local"
RSPSS_ALGS = ["eulertigs"]

if config["testing"]:
    DATASETS_AND_K_VALS = [("spneumo_pangenome_RASE_db.unitigs_k128", [31])]
    R_VALS = ["1.0"]
    testing_suffix = "__test"
else:
    testing_suffix = ""

### All combination of params to be tested
prefs_MS_comp_rates = set()
prefs_SPSS_comp_rates = set()
prefs_SBWT_comp_rates = set()
prefs_CBL_comp_rates = set()
for (g, K_vals) in DATASETS_AND_K_VALS:
    for k in K_vals:
        for S in CAMEL_ALGS:
            for d in filter(lambda d: d < k, D_VALS): # filter out d larger than k
                # here we can remove unwanted combinations / replace non-sense combinations of params
                if S in ["global"]:
                    d = "na"
                for r in R_VALS:
                    if r != "1.0" and (k not in SUBSAMPLED_KS or (g == "human_genome_assembly_chm13.v2.0" and k != 23)):
                        continue
                    if g not in DATASETS_NOT_SUBSAMPLED or r == "1.0":
                        prefs_MS_comp_rates.add(f"{g}.r_{r}.S_{S}.k_{k}.d_{d}")
        for r in R_VALS:
            if r != "1.0" and (k not in SUBSAMPLED_KS or (g == "human_genome_assembly_chm13.v2.0" and k != 23)):
                continue
            if g not in DATASETS_NOT_SUBSAMPLED or r == "1.0":
                for rspss in RSPSS_ALGS:
                    if (g== "human_genome_assembly_chm13.v2.0" and rspss == "eulertigs" and k == 17) \
                        or g.startswith("minikraken8"): # for HG and minikraken8GB
                        print(f"ADDING {g}.r_{r}.S_prophasm.k_{k}.d_na INSTEAD OF {g}.r_{r}.S_{rspss}.k_{k}.d_na")
                        prefs_SPSS_comp_rates.add(f"{g}.r_{r}.S_prophasm.k_{k}.d_na")
                    else:
                        prefs_SPSS_comp_rates.add(f"{g}.r_{r}.S_{rspss}.k_{k}.d_na")
                if k <= CBL_MAX_K:
                    prefs_CBL_comp_rates.add(f"{g}.r_{r}.S_none.k_{k}.d_na")
                if not g.startswith("minikraken"): # SBWT not for minikrakens -- too heavy disk usage (> 300 GB on tmp files)
                    prefs_SBWT_comp_rates.add(f"{g}.r_{r}.S_none.k_{k}.d_0")
                    prefs_SBWT_comp_rates.add(f"{g}.r_{r}.S_none.k_{k}.d_1") # two variants of SBWT
prefs_MS_comp_rates = sorted(list(prefs_MS_comp_rates))
prefs_SPSS_comp_rates = sorted(list(prefs_SPSS_comp_rates))
prefs_SBWT_comp_rates = sorted(list(prefs_SBWT_comp_rates))
prefs_CBL_comp_rates = sorted(list(prefs_CBL_comp_rates))



print(f"Prefs for FMSI (based on MS): {prefs_MS_comp_rates}")
print(f"Prefs for indexes on SPSS: {prefs_SPSS_comp_rates}")
print(f"Prefs for SBWT: {prefs_SBWT_comp_rates}")
print(f"Prefs for indexes on raw data: {prefs_CBL_comp_rates}")

################################################################

rule all:
    input:
        [f"99_results/exp_01_build_index_results.{g}.{HOSTNAME}{testing_suffix}.tsv" for g, _ in DATASETS_AND_K_VALS], # FIXME: missing {testing_suffix}
        f"00_hw_info/{HOSTNAME}.txt",

rule aggregate_data:
    input:
        "99_results/camel_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv",
        "99_results/fmsi_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv",
        "99_results/fmsi_query_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv",
        "99_results/rspss_comp_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv",
        "99_results/sshash_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv",
        "99_results/sshash_query_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv",
        "99_results/sbwt_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv",
        "99_results/sbwt_query_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv",
        "99_results/cbl_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv",
        "99_results/cbl_query_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv",
        "99_results/size_stats.{g}" + f".{HOSTNAME}{testing_suffix}.tsv",
    output:
        "99_results/exp_01_build_index_results.{g}" + f".{HOSTNAME}{testing_suffix}.tsv",
    params:
        suffix=testing_suffix
    shell:
        """
        cd 99_results/
        Rscript aggregate_data.R {wildcards.g} {params.suffix}
        """


#####################################################################################################
# AGGREGATE STATISTICS
#####################################################################################################


rule aggregate_size_stats:
    output:
        tsv="99_results/size_stats.{g}" + f".{HOSTNAME}{testing_suffix}.tsv",
    input:
        lambda wildcards: [f"80_size_stats/{HOSTNAME}/fmsi.{p}.stats.tsv" for p in prefs_MS_comp_rates if p.startswith(f"{wildcards.g}.")],
        lambda wildcards: [f"80_size_stats/{HOSTNAME}/sbwt.{p}.stats.tsv" for p in prefs_SBWT_comp_rates if p.startswith(f"{wildcards.g}.")],
        lambda wildcards: [f"80_size_stats/{HOSTNAME}/cbl.{p}.stats.tsv" for p in prefs_CBL_comp_rates if p.startswith(f"{wildcards.g}.")],
        lambda wildcards: [f"80_size_stats/{HOSTNAME}/sshash.{p}.stats.tsv" for p in prefs_SPSS_comp_rates if p.startswith(f"{wildcards.g}.")],
    params:
        tsv="99_results/size_stats.{g}" + f".{HOSTNAME}{testing_suffix}.tsv.tmp",
    priority: 500
    shell:
        """
        cat {input} \\
            | awk '!seen[$0]++' \\
            | tee {params.tsv} \\
            | python3 sort_output_tsv.py \\
            > {output.tsv}
        """
        
rule aggregate_camel_memtime_stats:
    output:
        tsv="99_results/camel_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv",
    input:
        lambda wildcards: [f"02_camel_memtime/{HOSTNAME}/{p}.t_superstring.tsv" for p in prefs_MS_comp_rates if p.startswith(f"{wildcards.g}.")],
    params:
        tsv="99_results/camel_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv.tmp",
    priority: 500
    shell:
        """
        cat {input} \\
            | awk '!seen[$0]++' \\
            | tee {params.tsv} \\
            | python3 sort_output_tsv.py \\
            > {output.tsv}
        """

rule aggregate_fmsi_memtime_stats:
    output:
        tsv="99_results/fmsi_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv",
    input:
        lambda wildcards: [f"03_fmsi_memtime/{HOSTNAME}/{p}.t_index.tsv" for p in prefs_MS_comp_rates if p.startswith(f"{wildcards.g}.")],
    params:
        tsv="99_results/fmsi_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv.tmp",
    priority: 500
    shell:
        """
        cat {input} \\
            | awk '!seen[$0]++' \\
            | tee {params.tsv} \\
            | python3 sort_output_tsv.py \\
            > {output.tsv}
        """

rule aggregate_fmsi_query_memtime_stats:
    output:
        tsv="99_results/fmsi_query_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv",
    input:
        lambda wildcards: [f"04_fmsi_query_memtime/{HOSTNAME}/{p}.t_Pos.tsv" for p in prefs_MS_comp_rates if p.startswith(f"{wildcards.g}.")],
        lambda wildcards: [f"04_fmsi_query_memtime/{HOSTNAME}/{p}.t_Neg.tsv" for p in prefs_MS_comp_rates if p.startswith(f"{wildcards.g}.")],
        lambda wildcards: [f"04_fmsi_query_memtime/{HOSTNAME}/{p}.t_Str.tsv" for p in prefs_MS_comp_rates if p.startswith(f"{wildcards.g}.")],
    params:
        tsv="99_results/fmsi_query_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv.tmp",
    priority: 500
    shell:
        """
        cat {input} \\
            | awk '!seen[$0]++' \\
            | tee {params.tsv} \\
            | python3 sort_output_tsv.py \\
            > {output.tsv}
        """

rule aggregate_rspss_comp_memtime_stats:
    output:
        tsv="99_results/rspss_comp_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv",
    input:
        lambda wildcards: [f"06_rspss_comp_memtime/{HOSTNAME}/{p}.t_superstring.tsv" for p in prefs_SPSS_comp_rates if p.startswith(f"{wildcards.g}.")],
    params:
        tsv="99_results/rspss_comp_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv.tmp",
    priority: 500
    shell:
        """
        cat {input} \\
            | awk '!seen[$0]++' \\
            | tee {params.tsv} \\
            | python3 sort_output_tsv.py \\
            > {output.tsv}
        """

rule aggregate_sshash_memtime_stats:
    output:
        tsv="99_results/sshash_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv",
    input:
        lambda wildcards: [f"26_sshash_memtime/{HOSTNAME}/{p}.t_index.tsv" for p in prefs_SPSS_comp_rates if p.startswith(f"{wildcards.g}.")],
    params:
        tsv="99_results/sshash_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv.tmp",
    priority: 500
    shell:
        """
        cat {input} \\
            | awk '!seen[$0]++' \\
            | tee {params.tsv} \\
            | python3 sort_output_tsv.py \\
            > {output.tsv}
        """

rule aggregate_sshash_query_memtime_stats:
    output:
        tsv="99_results/sshash_query_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv",
    input:
        lambda wildcards: [f"27_sshash_query_memtime/{HOSTNAME}/{p}.t_Pos.tsv" for p in prefs_SPSS_comp_rates if p.startswith(f"{wildcards.g}.")],
        lambda wildcards: [f"27_sshash_query_memtime/{HOSTNAME}/{p}.t_Neg.tsv" for p in prefs_SPSS_comp_rates if p.startswith(f"{wildcards.g}.")],
        lambda wildcards: [f"27_sshash_query_memtime/{HOSTNAME}/{p}.t_Str.tsv" for p in prefs_SPSS_comp_rates if p.startswith(f"{wildcards.g}.")],
    params:
        tsv="99_results/sshash_query_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv.tmp",
    priority: 500
    shell:
        """
        cat {input} \\
            | awk '!seen[$0]++' \\
            | tee {params.tsv} \\
            | python3 sort_output_tsv.py \\
            > {output.tsv}
        """

rule aggregate_cbl_memtime_stats:
    output:
        tsv="99_results/cbl_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv",
    input:
        lambda wildcards: [f"21_cbl_memtime/{HOSTNAME}/{p}.t_index.tsv" for p in prefs_CBL_comp_rates if p.startswith(f"{wildcards.g}.")],
    params:
        tsv="99_results/cbl_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv.tmp",
    priority: 500
    shell:
        """
        cat {input} \\
            | awk '!seen[$0]++' \\
            | tee {params.tsv} \\
            | python3 sort_output_tsv.py \\
            > {output.tsv}
        """

rule aggregate_cbl_query_memtime_stats:
    output:
        tsv="99_results/cbl_query_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv",
    input:
        lambda wildcards: [f"22_cbl_query_memtime/{HOSTNAME}/{p}.t_Pos.tsv" for p in prefs_CBL_comp_rates if p.startswith(f"{wildcards.g}.")],
        lambda wildcards: [f"22_cbl_query_memtime/{HOSTNAME}/{p}.t_Neg.tsv" for p in prefs_CBL_comp_rates if p.startswith(f"{wildcards.g}.")],
        lambda wildcards: [f"22_cbl_query_memtime/{HOSTNAME}/{p}.t_Str.tsv" for p in prefs_CBL_comp_rates if p.startswith(f"{wildcards.g}.")],
    params:
        tsv="99_results/cbl_query_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv.tmp",
    priority: 500
    shell:
        """
        cat {input} \\
            | awk '!seen[$0]++' \\
            | tee {params.tsv} \\
            | python3 sort_output_tsv.py \\
            > {output.tsv}
        """

# NOTE: we only take the stats for creating index w/o streaming support
rule aggregate_sbwt_memtime_stats:
    output:
        tsv="99_results/sbwt_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv",
    input:
        lambda wildcards: [f"11_sbwt_memtime/{HOSTNAME}/{p}.t_index.tsv" for p in prefs_SBWT_comp_rates if p.startswith(f"{wildcards.g}.")],
    params:
        tsv="99_results/sbwt_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv.tmp",
    priority: 500
    shell:
        """
        cat {input} \\
            | awk '!seen[$0]++' \\
            | tee {params.tsv} \\
            | python3 sort_output_tsv.py \\
            > {output.tsv}
        """

rule aggregate_sbwt_query_memtime_stats:
    output:
        tsv="99_results/sbwt_query_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv",
    input:
        lambda wildcards: [f"12_sbwt_query_memtime/{HOSTNAME}/{p}.t_Pos.tsv" for p in prefs_SBWT_comp_rates if p.startswith(f"{wildcards.g}.")],
        lambda wildcards: [f"12_sbwt_query_memtime/{HOSTNAME}/{p}.t_Neg.tsv" for p in prefs_SBWT_comp_rates if p.startswith(f"{wildcards.g}.")],
        lambda wildcards: [f"12_sbwt_query_memtime/{HOSTNAME}/{p}.t_Str.tsv" for p in prefs_SBWT_comp_rates if p.startswith(f"{wildcards.g}.")],
    params:
        tsv="99_results/sbwt_query_memtime.{g}" + f".{HOSTNAME}{testing_suffix}.tsv.tmp",
    priority: 500
    shell:
        """
        cat {input} \\
            | awk '!seen[$0]++' \\
            | tee {params.tsv} \\
            | python3 sort_output_tsv.py \\
            > {output.tsv}
        """

rule link_for_non_subsampled:
    input:
        fa=f"{DATA_DIR}" + "{g}.fa",
    output:
        fa=f"{DATA_DIR}" + "{g}_subsampled_k{k}_r1.0.fa",
    params:
        datadir=DATA_DIR
    shell:
        """
        cd {params.datadir}
        ln -s  $(basename {input.fa}) $(basename {output.fa})
        """

#####################################################################################################
# COMPUTE QUERY FILE
#####################################################################################################

rule compute_queries_positive_wgsim_genomes:
    input:
        fa=f"{DATA_DIR}" + "{g}_subsampled_k{k}_r1.0.fa",
    output:
        q="42_query_fastas/{g}.r_1.0.k_{k}-queries.fa",
    wildcard_constraints:
        g="placeholder|" + '|'.join([d for d, _ in DATASETS_AND_K_VALS if not d.startswith("minikraken") and not ".unitigs_" in d]),
    params:
        mut_rate=0,
        seq_len="{k}",
        num_seqs=NUM_QUERIED_KMERS,
        std_dev=WGSIM_STD_DEV,
    priority: 200
    shell:
        """
        ./simulate_wgsim.sh {input.fa} {params.mut_rate} {params.seq_len} {params.num_seqs} {params.std_dev} >{output.q}
        """

rule compute_queries_positive_wgsim:
    input:
        fa=RSPSS_DIR+"{g}.r_1.0.S_eulertigs.k_95.d_na.fa", # compute eulertigs for k=95 (assuming WGSIM_STD_DEV < 32)
    output:
        q="42_query_fastas/{g}.r_1.0.k_{k}-queries.fa",
    wildcard_constraints:
        g="placeholder|" + '|'.join([d for d, _ in DATASETS_AND_K_VALS if not d.startswith("minikraken") and ".unitigs_k128" in d]),
    params:
        mut_rate=0,
        seq_len="{k}",
        num_seqs=NUM_QUERIED_KMERS,
        std_dev=WGSIM_STD_DEV,
    priority: 200
    shell:
        """
        ./simulate_wgsim.sh {input.fa} {params.mut_rate} {params.seq_len} {params.num_seqs} {params.std_dev} >{output.q}
        """

rule compute_queries_positive_python_script:
    input:
        fa=f"{DATA_DIR}" + "{g}_subsampled_k{k}_r{r}.fa",
    output:
        q="42_query_fastas/{g}.r_{r}.k_{k}-queries.fa",
    wildcard_constraints:
        g="placeholder|" + '|'.join([d for d, _ in DATASETS_AND_K_VALS if d.startswith("minikraken") or "unitigs_minfreq2_k32" in d]),
    params:
        get_queries=GET_QUERIES,
        num_queries=NUM_QUERIED_KMERS,
    shell:
        """
        {params.get_queries} -k {wildcards.k} -cap {params.num_queries} -print_header True {input.fa} >{output.q}
        """

# for subsampled, we generate queries from a prefix of file
rule compute_queries_positive_subsampled:
    input:
        fa=f"{DATA_DIR}" + "{g}_subsampled_k{k}_r{r}.fa",
    output:
        q="42_query_fastas/{g}.r_{r}.k_{k}-queries.fa",
    wildcard_constraints:
        r="placeholder|" + '|'.join([rr for rr in R_VALS if rr != "1.0"]),
    params:
        num_lines=2*NUM_QUERIED_KMERS,
    priority: 200
    shell:
        """
        head -n {params.num_lines} {input.fa} >{output.q}
        """


rule compute_queries_positive_wRCs:
    input:
        q="42_query_fastas/{g}.r_{r}.k_{k}-queries.fa",
    output:
        q="42_query_fastas/{g}.r_{r}.k_{k}-queries-wRCs.fa",
    shell:
        """
        (
            seqtk seq {input.q} 
            seqtk seq -r {input.q} | perl -pe 's/>/>RC_/g'
        ) >{output.q}
        """
        
rule compute_queries_negative:
    output:
        q="42_query_fastas/negative_queries.k_{k}.fa",
    wildcard_constraints:
        k="\\d+" 
    params:
        refGenomeFa=NEGATIVE_QUERIES_REF_FASTA,
        mut_rate=NEGATIVE_QUERIES_MUT_RATE,
        seq_len="{k}",
        num_seqs=NUM_QUERIED_KMERS,
        std_dev=WGSIM_STD_DEV,
    shell:
        """
        ./simulate_wgsim.sh {params.refGenomeFa} {params.mut_rate} {params.seq_len} {params.num_seqs} {params.std_dev} >{output.q}
        """

rule compute_queries_negative_wRCs:
    input:
        q="42_query_fastas/negative_queries.k_{k}.fa",
    output:
        q="42_query_fastas/negative_queries.k_{k}-wRCs.fa",
    shell:
        """
        (
            seqtk seq {input.q} 
            seqtk seq -r {input.q} | perl -pe 's/>/>RC_/g'
        ) >{output.q}
        """
        
def GetNumSeqs4StreamingQueries(seq_len, num_queried_kmers, wildcards):
    return int(num_queried_kmers) // (int(seq_len) - int(wildcards.k) + 1)

rule compute_queries_streaming:
    output:
        q="42_query_fastas/{g}.k_{k}-queries-str.fa",
    params:
        mut_rate=0,
        seq_len=STREAMING_SEQUENCES_LENGTH,
        num_seqs=lambda wildcards: GetNumSeqs4StreamingQueries(STREAMING_SEQUENCES_LENGTH, NUM_QUERIED_KMERS, wildcards),
        std_dev=WGSIM_STD_DEV,
        refGenomeFa="../../data/{g}-refGenome.fa",
    shell:
        """
        ./simulate_wgsim.sh {params.refGenomeFa} {params.mut_rate} {params.seq_len} {params.num_seqs} {params.std_dev} >{output.q}
        """

rule compute_queries_streaming_wRCs:
    input:
        q="42_query_fastas/{g}.k_{k}-queries-str.fa",
    output:
        q="42_query_fastas/{g}.k_{k}-queries-str-wRCs.fa",
    shell:
        """
        (
            seqtk seq {input.q} 
            seqtk seq -r {input.q} | perl -pe 's/>/>RC_/g'
        ) >{output.q}
        """

#####################################################################################################
# COUNT KMERS
#####################################################################################################

# TO AVOID COUNTING K-MERS MORE TIMES: we assume that eulertigs is always run for every genome, rate, and k
rule count_kmers:
    output:
        txt="80_size_stats/{g}.r_{r}.k_{k}.kmerCount",
    input:
        fa=RSPSS_DIR+"{g}.r_{r}.S_eulertigs.k_{k}.d_na.fa",
    shell:
        """
        ../../scripts/count_kmers_jellyfish.sh {input.fa} {wildcards.k} {output.txt}
        """



#####################################################################################################
# RUN CAMEL + FMSI
#####################################################################################################

# includes mask optimization
rule run_kmer_camel:
    input:
        fa=f"{DATA_DIR}" + "{g}_subsampled_k{k}_r{r}.fa",
        hw=f"00_hw_info/{HOSTNAME}.txt",
    output:
        fa="01_MS_index/{g}.r_{r}.S_{S}.k_{k}.d_{d}.fa",
        log0=f"02_camel_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_{S}.k_{k}.d_{d}.t_superstring.log",
    wildcard_constraints:
        S='|'.join(CAMEL_ALGS),
    params:
        d_param=lambda wildcards: f"-d {wildcards.d}" if wildcards.d != "na" else "",
        tmpfa="01_MS_index/{g}.r_{r}.S_{S}.k_{k}.d_{d}-no-opt.fa",
        camel=CAMEL,
    shell:
        """
        ../../scripts/benchmark.py --log "{output.log0}" "{params.camel} -c -k {wildcards.k} {params.d_param} -p {input.fa} -a {wildcards.S} >{params.tmpfa}; {params.camel} optimize -c -k {wildcards.k} -p {params.tmpfa} -a ones >{output.fa}; rm {params.tmpfa}"
        """

rule run_fmsi:
    input:
        fa="01_MS_index/{g}.r_{r}.S_{S}.k_{k}.d_{d}.fa",
    output:
        ac="01_MS_index/{g}.r_{r}.S_{S}.k_{k}.d_{d}.fa.fmsi.ac",
        gt="01_MS_index/{g}.r_{r}.S_{S}.k_{k}.d_{d}.fa.fmsi.gt",
        ac_gt="01_MS_index/{g}.r_{r}.S_{S}.k_{k}.d_{d}.fa.fmsi.ac_gt",
        klcp="01_MS_index/{g}.r_{r}.S_{S}.k_{k}.d_{d}.fa.fmsi.klcp",
        mask="01_MS_index/{g}.r_{r}.S_{S}.k_{k}.d_{d}.fa.fmsi.mask",
        misc="01_MS_index/{g}.r_{r}.S_{S}.k_{k}.d_{d}.fa.fmsi.misc",
        log0=f"03_fmsi_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_{S}.k_{k}.d_{d}.t_index.log",
    wildcard_constraints:
        S='|'.join(CAMEL_ALGS),
    params:
        fmsi=FMSI,
    shell:
        """
        ../../scripts/benchmark.py --log "{output.log0}" \\
            "{params.fmsi} index {input.fa}" 
        """

rule run_fmsi_query_pos:
    input:
        fa="01_MS_index/{g}.r_{r}.S_{S}.k_{k}.d_{d}.fa",
        klcp="01_MS_index/{g}.r_{r}.S_{S}.k_{k}.d_{d}.fa.fmsi.klcp",
        mask="01_MS_index/{g}.r_{r}.S_{S}.k_{k}.d_{d}.fa.fmsi.mask",
        qPos="42_query_fastas/{g}.r_{r}.k_{k}-queries.fa",
    output:
        logPos=f"04_fmsi_query_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_{S}.k_{k}.d_{d}.t_Pos.log",
    wildcard_constraints:
        S='|'.join(CAMEL_ALGS),
    params:
        fmsi=FMSI,
    shell:
        """
        ../../scripts/benchmark.py --log "{output.logPos}" \\
            "{params.fmsi} query -O -q {input.qPos} {input.fa} >/dev/null" 
        """

rule run_fmsi_query_neg:
    input:
        fa="01_MS_index/{g}.r_{r}.S_{S}.k_{k}.d_{d}.fa",
        klcp="01_MS_index/{g}.r_{r}.S_{S}.k_{k}.d_{d}.fa.fmsi.klcp",
        mask="01_MS_index/{g}.r_{r}.S_{S}.k_{k}.d_{d}.fa.fmsi.mask",
        qNeg="42_query_fastas/negative_queries.k_{k}.fa",
    output:
        logNeg=f"04_fmsi_query_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_{S}.k_{k}.d_{d}.t_Neg.log",
    wildcard_constraints:
        S='|'.join(CAMEL_ALGS),
    params:
        fmsi=FMSI,
    shell:
        """
        ../../scripts/benchmark.py --log "{output.logNeg}" \\
            "{params.fmsi} query -O -q {input.qNeg} {input.fa} >/dev/null" 
        """

rule run_fmsi_query_str:
    input:
        fa="01_MS_index/{g}.r_{r}.S_{S}.k_{k}.d_{d}.fa",
        klcp="01_MS_index/{g}.r_{r}.S_{S}.k_{k}.d_{d}.fa.fmsi.klcp",
        mask="01_MS_index/{g}.r_{r}.S_{S}.k_{k}.d_{d}.fa.fmsi.mask",
        qStr="42_query_fastas/{g}.k_{k}-queries-str.fa",
    output:
        logStr=f"04_fmsi_query_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_{S}.k_{k}.d_{d}.t_Str.log",
    wildcard_constraints:
        S='|'.join(CAMEL_ALGS),
    params:
        fmsi=FMSI,
    shell:
        """
        ../../scripts/benchmark.py --log "{output.logStr}" \\
            "{params.fmsi} query -O -S -q {input.qStr} {input.fa} >/dev/null 2>/dev/null" 
        """

rule make_fmsi_stats:
    input:
        ac="01_MS_index/{g}.r_{r}.S_{S}.k_{k}.d_{d}.fa.fmsi.ac",
        gt="01_MS_index/{g}.r_{r}.S_{S}.k_{k}.d_{d}.fa.fmsi.gt",
        ac_gt="01_MS_index/{g}.r_{r}.S_{S}.k_{k}.d_{d}.fa.fmsi.ac_gt",
        klcp="01_MS_index/{g}.r_{r}.S_{S}.k_{k}.d_{d}.fa.fmsi.klcp",
        mask="01_MS_index/{g}.r_{r}.S_{S}.k_{k}.d_{d}.fa.fmsi.mask",
        misc="01_MS_index/{g}.r_{r}.S_{S}.k_{k}.d_{d}.fa.fmsi.misc",
        kmerCnt="80_size_stats/{g}.r_{r}.k_{k}.kmerCount",
    output:
        stats=f"80_size_stats/{HOSTNAME}/" + "fmsi.{g}.r_{r}.S_{S}.k_{k}.d_{d}.stats.tsv"
    params:
        pref="fmsi.{g}.S_{S}.k_{k}.d_{d}",
    priority: 50
    shell:
        """
        (
        #1
        printf '%s\\t%s\\t%s\\t%s\\t%s\\t%s' genome rate I_alg S_alg k d
        printf '\\t'

        #2
        printf '%s\\t%s\\t%s\\t%s' kmer_count index_bytes index_bytes_streaming
        printf '\\t'

        # final
        printf '%s' pref
        printf '\\n'


        ##################################

        #1
        printf '%s\\t%s\\t%s\\t%s\\t%s\\t%s' \\
            {wildcards.g} \\
            {wildcards.r} \\
            "fmsi" \\
            {wildcards.S} \\
            {wildcards.k} \\
            {wildcards.d} 
        printf '\\t'

        #2
        printf '%d\\t%d\\t%d' \\
            $(cat {input.kmerCnt} | xargs echo) \\
            $(cat {input.ac} {input.gt} {input.ac_gt} {input.misc} {input.mask} | wc -c) \\
            $(cat {input.ac} {input.gt} {input.ac_gt} {input.misc} {input.klcp} {input.mask} | wc -c)
        printf '\\t'

        #final
        printf '%s' \\
            {params.pref}
        printf '\\n'

        ) > {output.stats}
        """

        


#####################################################################################################
# RUN PROPHASM or GGCAT
#####################################################################################################

rule run_prophasm:
    input:
        fa=f"{DATA_DIR}" + "{g}_subsampled_k{k}_r{r}.fa",
    output:
        fa=RSPSS_DIR+"{g}.r_{r}.S_prophasm.k_{k}.d_na.fa",
        log0=f"06_rspss_comp_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_prophasm.k_{k}.d_na.t_superstring.log",
    params:
        prophasm=PROPHASM,
    shell:
        """
        ../../scripts/benchmark.py --log "{output.log0}" \\
            "{params.prophasm} -k {wildcards.k} -i {input.fa} -o {output.fa}"
        """

rule compute_ggcat_eulertigs:
    input:
        fa=f"{DATA_DIR}" + "{g}_subsampled_k{k}_r{r}.fa",
    output:
        fa=RSPSS_DIR+"{g}.r_{r}.S_eulertigs.k_{k}.d_na.fa",
        log0=f"06_rspss_comp_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_eulertigs.k_{k}.d_na.t_superstring.log",
    params:
        ggcat=GGCAT,
        ggcat_mem = 200,
    shell:
        """
        ../../scripts/benchmark.py --log "{output.log0}" \\
            "{params.ggcat} build -k {wildcards.k} --eulertigs --min-multiplicity 1 --memory {params.ggcat_mem} --threads-count 1 -o {output.fa} {input.fa}"
        """

#####################################################################################################
# RUN SSHash on SPSS
#####################################################################################################

def SSHASH_prog_path(wildcards):
    if int(wildcards.k) <= 31:
        return SSHASH
    if int(wildcards.k) <= 63:
        return SSHASH_LARGE_K

# mimimizer len. is now determined by a bash script from k and kmer_count
rule run_sshash:
    input:
        fa=RSPSS_DIR+"{g}.r_{r}.S_{S}.k_{k}.d_na.fa",
        kmerCnt="80_size_stats/{g}.r_{r}.k_{k}.kmerCount"
    output:
        index="25_sshash_index/{g}.r_{r}.S_{S}.k_{k}.d_na.sshash",
        log0=f"26_sshash_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_{S}.k_{k}.d_na.t_index.log",
    params:
        sshash=lambda wildcards: SSHASH_prog_path(wildcards),
        tmpinput="25_sshash_index/{g}.r_{r}.S_{S}.k_{k}.d_na.fa",
    shell:
        """
        seqtk seq {input.fa} >{params.tmpinput}
        ../../scripts/benchmark.py --log "{output.log0}" \\
            "{params.sshash} build -i {params.tmpinput} -k {wildcards.k} -m $(./getMinimizerLen4SSHash.py {wildcards.k} {input.kmerCnt}) -o {output.index} -s `echo $RANDOM`"
        rm {params.tmpinput}
        """

rule run_sshash_query_pos:
    input:
        index="25_sshash_index/{g}.r_{r}.S_{S}.k_{k}.d_na.sshash",
        qPos="42_query_fastas/{g}.r_{r}.k_{k}-queries.fa",
    output:
        logPos=f"27_sshash_query_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_{S}.k_{k}.d_na.t_Pos.log",
    params:
        sshash=lambda wildcards: SSHASH_prog_path(wildcards),
    shell:
        """
        ../../scripts/benchmark.py --log "{output.logPos}" \\
            "{params.sshash} query -i {input.index} -q {input.qPos}"
        """

rule run_sshash_query_neg:
    input:
        index="25_sshash_index/{g}.r_{r}.S_{S}.k_{k}.d_na.sshash",
        qNeg="42_query_fastas/negative_queries.k_{k}.fa",
    output:
        logNeg=f"27_sshash_query_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_{S}.k_{k}.d_na.t_Neg.log",
    params:
        sshash=lambda wildcards: SSHASH_prog_path(wildcards),
    shell:
        """
        ../../scripts/benchmark.py --log "{output.logNeg}" \\
            "{params.sshash} query -i {input.index} -q {input.qNeg}"
        """

rule run_sshash_query_str:
    input:
        index="25_sshash_index/{g}.r_{r}.S_{S}.k_{k}.d_na.sshash",
        qStr="42_query_fastas/{g}.k_{k}-queries-str.fa",
    output:
        logStr=f"27_sshash_query_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_{S}.k_{k}.d_na.t_Str.log",
    params:
        sshash=lambda wildcards: SSHASH_prog_path(wildcards),
    shell:
        """
        ../../scripts/benchmark.py --log "{output.logStr}" \\
            "{params.sshash} query -i {input.index} -q {input.qStr}"
        """

rule make_sshash_stats:
    input:
        index="25_sshash_index/{g}.r_{r}.S_{S}.k_{k}.d_na.sshash",
        kmerCnt="80_size_stats/{g}.r_{r}.k_{k}.kmerCount",
    output:
        stats=f"80_size_stats/{HOSTNAME}/" + "sshash.{g}.r_{r}.S_{S}.k_{k}.d_{d}.stats.tsv",
    params:
        pref="sshash.{g}.S_{S}.k_{k}.d_{d}",
    priority: 50
    shell:
        """
        (
        #1
        printf '%s\\t%s\\t%s\\t%s\\t%s\\t%s' genome rate I_alg S_alg k d
        printf '\\t'

        #2
        printf '%s\\t%s\\t%s\\t%s' kmer_count index_bytes index_bytes_streaming
        printf '\\t'

        # final
        printf '%s' pref
        printf '\\n'

        ##################################

        #1
        printf '%s\\t%s\\t%s\\t%s\\t%s\\t%s' \\
            {wildcards.g} \\
            {wildcards.r} \\
            SSHash \\
            {wildcards.S} \\
            {wildcards.k} \\
            {wildcards.d} 
        printf '\\t'

        #2
        printf '%d\\t%d\\t%d' \\
            $(cat {input.kmerCnt} | xargs echo) \\
            $(cat {input.index} | wc -c) \\
            $(cat {input.index} | wc -c)
        printf '\\t'

        #final
        printf '%s' \\
            {params.pref}
        printf '\\n'

        ) > {output.stats}
        """


#####################################################################################################
# RUN SBWT
#####################################################################################################

# Two variants
# - d=0: SBWT_VARIANT with param. --add-reverse-complements, which handles reverse complements (RCs)
# - d=1: SBWT_VARIANT_MEM param.  WITHOUT reverse complements; this is supposed to be more memory efficient than the default variant but slower
# Both need the same input file (uncompressed), so both are handled by this rule (can also separate jobs for both runs)

def SBWT_prog_path(wildcards):
    if int(wildcards.k) <= 32:
        return SBWT
    if int(wildcards.k) <= 64:
        return SBWT_LARGE_K

rule build_sbwt:
    input:
        fa=f"{DATA_DIR}" + "{g}_subsampled_k{k}_r{r}.fa",
    output:
        sbwt=SBWT_DIR + "{g}.r_{r}.S_none.k_{k}.d_0.fa.sbwt",
        sbwtStreaming=SBWT_DIR + "{g}.r_{r}.S_none.k_{k}.d_0.fa-Streaming.sbwt",
        sbwt_mem=SBWT_DIR + "{g}.r_{r}.S_none.k_{k}.d_1.fa.sbwt",
        sbwt_memStreaming=SBWT_DIR + "{g}.r_{r}.S_none.k_{k}.d_1.fa-Streaming.sbwt",
        log0=f"11_sbwt_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_none.k_{k}.d_0.t_index.log",
        log0Streaming=f"11_sbwt_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_none.k_{k}.d_0.t_indexStreaming.log", # in fact, it's not included in stats now
        log0_mem=f"11_sbwt_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_none.k_{k}.d_1.t_index.log",
        log0_memStreaming=f"11_sbwt_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_none.k_{k}.d_1.t_indexStreaing.log", # in fact, it's not included in stats now
    resources:
        sbwtlimit=1, # !!! run <= 1 instance due to excessive disk consumption (on E.coli pan-genome (all) nearly 100 GBs, got 84G for sbwt_tmp_escherichia_coli.k63_subsampled_k23_r0.1.fa)
    params:
        sbwt=lambda wildcards: SBWT_prog_path(wildcards),
        sbwtVariant=SBWT_VARIANT,
        sbwtVariantMem=SBWT_VARIANT_MEM,
        threads=NUM_THREADS,
        memory=SBWT_RAM,
        tmpdir=SBWT_TMP_DIR+"sbwt_tmp_{g}_subsampled_k{k}_r{r}.fa/",
    priority: 100
    shell:
        """
        mkdir -p {params.tmpdir}
        ### TIME EFFICIENT VARIANT
        # no streaming
        ../../scripts/benchmark.py --log "{output.log0}" \\
            "{params.sbwt} build -k {wildcards.k} -t {params.threads} -m {params.memory} -d {params.tmpdir} -i {input.fa} -o {output.sbwt} --add-reverse-complements --variant {params.sbwtVariant} --no-streaming-support"
        rm -rf {params.tmpdir}*
        # with streaming
        ../../scripts/benchmark.py --log "{output.log0Streaming}" \\
            "{params.sbwt} build -k {wildcards.k} -t {params.threads} -m {params.memory} -d {params.tmpdir} -i {input.fa} -o {output.sbwtStreaming} --add-reverse-complements --variant {params.sbwtVariant}"
        rm -rf {params.tmpdir}*
        ### MEMORY EFFICIENT VARIANT
        # no streaming
        ../../scripts/benchmark.py --log "{output.log0_mem}" \\
            "{params.sbwt} build -k {wildcards.k} -t {params.threads} -m {params.memory} -d {params.tmpdir} -i {input.fa} -o {output.sbwt_mem} --variant {params.sbwtVariantMem} --no-streaming-support"
        rm -rf {params.tmpdir}*
        # with streaming
        ../../scripts/benchmark.py --log "{output.log0_memStreaming}" \\
            "{params.sbwt} build -k {wildcards.k} -t {params.threads} -m {params.memory} -d {params.tmpdir} -i {input.fa} -o {output.sbwt_memStreaming} --variant {params.sbwtVariantMem}"
        rm -rf {params.tmpdir}
        """

rule run_sbwt_query_pos:
    input:
        sbwt=SBWT_DIR + "{g}.r_{r}.S_none.k_{k}.d_0.fa.sbwt",
        sbwt_mem=SBWT_DIR + "{g}.r_{r}.S_none.k_{k}.d_1.fa.sbwt",
        qPos="42_query_fastas/{g}.r_{r}.k_{k}-queries.fa",
        qPosRCs="42_query_fastas/{g}.r_{r}.k_{k}-queries-wRCs.fa",
    output:
        logPos=f"12_sbwt_query_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_none.k_{k}.d_0.t_Pos.log",
        logPosMem=f"12_sbwt_query_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_none.k_{k}.d_1.t_Pos.log",
    params:
        sbwt=lambda wildcards: SBWT_prog_path(wildcards),
    shell:
        """
        ### TIME EFFICIENT VARIANT
        ../../scripts/benchmark.py --log "{output.logPos}" \\
            "{params.sbwt} search -i {input.sbwt} -q {input.qPos} -o /dev/null"
        ### MEMORY EFFICIENT VARIANT
        ../../scripts/benchmark.py --log "{output.logPosMem}" \\
            "{params.sbwt} search -i {input.sbwt_mem} -q {input.qPosRCs} -o /dev/null"
        """

rule run_sbwt_query_neg:
    input:
        sbwt=SBWT_DIR + "{g}.r_{r}.S_none.k_{k}.d_0.fa.sbwt",
        sbwt_mem=SBWT_DIR + "{g}.r_{r}.S_none.k_{k}.d_1.fa.sbwt",
        qNeg="42_query_fastas/negative_queries.k_{k}.fa",
        qNegRCs="42_query_fastas/negative_queries.k_{k}-wRCs.fa",
    output:
        logNeg=f"12_sbwt_query_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_none.k_{k}.d_0.t_Neg.log",
        logNegMem=f"12_sbwt_query_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_none.k_{k}.d_1.t_Neg.log",
    params:
        sbwt=lambda wildcards: SBWT_prog_path(wildcards),
    shell:
        """
        ### TIME EFFICIENT VARIANT
        ../../scripts/benchmark.py --log "{output.logNeg}" \\
            "{params.sbwt} search -i {input.sbwt} -q {input.qNeg} -o /dev/null"
        ### MEMORY EFFICIENT VARIANT
        ../../scripts/benchmark.py --log "{output.logNegMem}" \\
            "{params.sbwt} search -i {input.sbwt_mem} -q {input.qNegRCs} -o /dev/null"
        """

rule run_sbwt_query_str:
    input:
        sbwtStreaming=SBWT_DIR + "{g}.r_{r}.S_none.k_{k}.d_0.fa-Streaming.sbwt",
        sbwt_memsStreaming=SBWT_DIR + "{g}.r_{r}.S_none.k_{k}.d_1.fa-Streaming.sbwt",
        qStr="42_query_fastas/{g}.k_{k}-queries-str.fa",
        qStrRCs="42_query_fastas/{g}.k_{k}-queries-str-wRCs.fa",
    output:
        logStr=f"12_sbwt_query_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_none.k_{k}.d_0.t_Str.log",
        logStrMem=f"12_sbwt_query_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_none.k_{k}.d_1.t_Str.log",
    params:
        sbwt=lambda wildcards: SBWT_prog_path(wildcards),
    shell:
        """
        ### TIME EFFICIENT VARIANT
        ../../scripts/benchmark.py --log "{output.logStr}" \\
            "{params.sbwt} search -i {input.sbwtStreaming} -q {input.qStr} -o /dev/null"
        ### MEMORY EFFICIENT VARIANT
        ../../scripts/benchmark.py --log "{output.logStrMem}" \\
            "{params.sbwt} search -i {input.sbwt_memsStreaming} -q {input.qStrRCs} -o /dev/null"
        """

rule make_sbwt_stats:
    input:
        sbwt=SBWT_DIR + "{g}.r_{r}.S_none.k_{k}.d_{d}.fa.sbwt",
        sbwtStreaming=SBWT_DIR + "{g}.r_{r}.S_none.k_{k}.d_{d}.fa-Streaming.sbwt",
        kmerCnt="80_size_stats/{g}.r_{r}.k_{k}.kmerCount",
    output:
        stats=f"80_size_stats/{HOSTNAME}/" + "sbwt.{g}.r_{r}.S_{S}.k_{k}.d_{d}.stats.tsv"
    params:
        pref="sbwt.{g}.S_{S}.k_{k}.d_{d}",
    priority: 50
    shell:
        """
        (
        #1
        printf '%s\\t%s\\t%s\\t%s\\t%s\\t%s' genome rate I_alg S_alg k d
        printf '\\t'

        #2
        printf '%s\\t%s\\t%s\\t%s' kmer_count index_bytes index_bytes_streaming
        printf '\\t'

        # final
        printf '%s' pref
        printf '\\n'

        ##################################

        #1
        printf '%s\\t%s\\t%s\\t%s\\t%s\\t%s' \\
            {wildcards.g} \\
            {wildcards.r} \\
            "sbwt" \\
            {wildcards.S} \\
            {wildcards.k} \\
            {wildcards.d} 
        printf '\\t'

        #2
        printf '%d\\t%d\\t%d' \\
            $(cat {input.kmerCnt} | xargs echo) \\
            $(cat {input.sbwt} | wc -c) \\
            $(cat {input.sbwtStreaming} | wc -c)
        printf '\\t'

        #final
        printf '%s' \\
            {params.pref}
        printf '\\n'

        ) > {output.stats}
        """

#####################################################################################################
# RUN CBL directly on the FASTA file
#####################################################################################################

rule run_cbl:
    input:
        fa=f"{DATA_DIR}" + "{g}_subsampled_k{k}_r{r}.fa",
    output:
        ind="20_cbl_index/{g}.r_{r}.S_none.k_{k}.d_na.fa.cblIndex",
        log0=f"21_cbl_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_none.k_{k}.d_na.t_index.log",
    params:
        cbl=CBL_PREF + "{k}" + CBL_SUFF,
        tmpinput="20_cbl_index/{g}_subsampled_k{k}_r{r}.fa",
    shell:
        """
        ../../scripts/benchmark.py --log "{output.log0}" \\
            "{params.cbl} build -c -o {output.ind} {input.fa}"
        """

rule run_cbl_query_pos:
    input:
        ind="20_cbl_index/{g}.r_{r}.S_none.k_{k}.d_na.fa.cblIndex",
        qPos="42_query_fastas/{g}.r_{r}.k_{k}-queries.fa",
    output:
        logPos=f"22_cbl_query_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_none.k_{k}.d_na.t_Pos.log",
    params:
        cbl=CBL_PREF + "{k}" + CBL_SUFF,
    shell:
        """
        ../../scripts/benchmark.py --log "{output.logPos}" \\
            "{params.cbl} query {input.ind} {input.qPos} >/dev/null"
        """

rule run_cbl_query_neg:
    input:
        ind="20_cbl_index/{g}.r_{r}.S_none.k_{k}.d_na.fa.cblIndex",
        qNeg="42_query_fastas/negative_queries.k_{k}.fa",
    output:
        logNeg=f"22_cbl_query_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_none.k_{k}.d_na.t_Neg.log",
    params:
        cbl=CBL_PREF + "{k}" + CBL_SUFF,
    shell:
        """
        ../../scripts/benchmark.py --log "{output.logNeg}" \\
            "{params.cbl} query {input.ind} {input.qNeg} >/dev/null"
        """

rule run_cbl_query_str:
    input:
        ind="20_cbl_index/{g}.r_{r}.S_none.k_{k}.d_na.fa.cblIndex",
        qStr="42_query_fastas/{g}.k_{k}-queries-str.fa",
    output:
        logStr=f"22_cbl_query_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_none.k_{k}.d_na.t_Str.log",
    params:
        cbl=CBL_PREF + "{k}" + CBL_SUFF,
    shell:
        """
        ../../scripts/benchmark.py --log "{output.logStr}" \\
            "{params.cbl} query {input.ind} {input.qStr} >/dev/null"
        """

rule make_cbl_stats:
    input:
        ind="20_cbl_index/{g}.r_{r}.S_none.k_{k}.d_na.fa.cblIndex",
        kmerCnt="80_size_stats/{g}.r_{r}.k_{k}.kmerCount",
    output:
        stats=f"80_size_stats/{HOSTNAME}/" + "cbl.{g}.r_{r}.S_{S}.k_{k}.d_{d}.stats.tsv",
    params:
        pref="cbl.{g}.S_{S}.k_{k}.d_{d}",
    priority: 50
    shell:
        """
        (
        #1
        printf '%s\\t%s\\t%s\\t%s\\t%s\\t%s' genome rate I_alg S_alg k d
        printf '\\t'

        #2
        printf '%s\\t%s\\t%s\\t%s' kmer_count index_bytes index_bytes_streaming
        printf '\\t'

        # final
        printf '%s' pref
        printf '\\n'

        ##################################

        #1
        printf '%s\\t%s\\t%s\\t%s\\t%s\\t%s' \\
            {wildcards.g} \\
            {wildcards.r} \\
            "cbl" \\
            {wildcards.S} \\
            {wildcards.k} \\
            {wildcards.d} 
        printf '\\t'

        #2
        printf '%d\\t%d\\t%d' \\
            $(cat {input.kmerCnt} | xargs echo) \\
            $(cat {input.ind} | wc -c) \\
            $(cat {input.ind} | wc -c)
        printf '\\t'

        #final
        printf '%s' \\
            {params.pref}
        printf '\\n'

        ) > {output.stats}
        """

#####################################################################################################
# REFORMATTING MEMTIME LOG (for all algs.)
#####################################################################################################

def GetNumQueries(wildcards):
    if wildcards.t == "Pos" or wildcards.t == "Neg":
        return NUM_QUERIED_KMERS
    elif wildcards.t == "Str":
        return GetNumSeqs4StreamingQueries(STREAMING_SEQUENCES_LENGTH, NUM_QUERIED_KMERS, wildcards) * (int(STREAMING_SEQUENCES_LENGTH) - int(wildcards.k) + 1)
    else: # t == index or superstring
        return 0


rule reformat_memtime_logs:
    output:
        "{dir}" + f"_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_{S}.k_{k}.d_{d}.t_{t}.tsv",
    input:
        "{dir}" + f"_memtime/{HOSTNAME}/" + "{g}.r_{r}.S_{S}.k_{k}.d_{d}.t_{t}.log",
    params:
        pref="{g}.r_{r}.S_{S}.k_{k}.d_{d}.t_{t}",
        num_queries=lambda wildcards: GetNumQueries(wildcards),
    priority: 50
    shell:
        """
        (
            printf 'pref\\tgenome\\trate\\tprog\\tS_alg\\tk\\td\\tqType\\tnum_queries\\t'

            cat {input} \\
                | grep real

            printf '%s\\t%s\\t%s\\t%s\\t%s\\t%d\\t%s\\t%s\\t%s\\t' \\
                {params.pref} \\
                {wildcards.g} \\
                {wildcards.r} \\
                {wildcards.dir} \\
                {wildcards.S} \\
                {wildcards.k} \\
                {wildcards.d} \\
                {wildcards.t} \\
                {params.num_queries} \\
            ;

            cat {input} \\
                | grep -Ev '(real|#)'

        ) > {output}
        """


#####################################################################################################
# GET HW INFO ABOUT THE CURRENT COMPUTER
#####################################################################################################


rule add_hw_info:
    output:
        hw=f"00_hw_info/{HOSTNAME}.txt",
    priority: 50
    shell:
        """
        ../../scripts/print_hw_info.sh > {output.hw}
        """
